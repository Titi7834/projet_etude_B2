<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PyChallenge - Programmation orient√©e objet</title>
    <link rel="stylesheet" href="styles/chapitre5.css">
</head>
<body>
    <header>
        <div class="navbar">
            <div style="display: flex; align-items: center;">
                <button class="mobile-toggle" id="mobileToggle">‚ò∞</button>
                <a href="index.html" class="logo">Py<span>Challenge</span></a>
                <div class="doc-title">Documentation Python</div>
            </div>
            <ul class="nav-links">
                <li><a href="explorer.html">D√©fis</a></li>
                <li><a href="apprendre.html">Apprendre</a></li>
            </ul>
        </div>
    </header>

    <div class="main-container">
        <aside class="sidebar" id="sidebar">
            <div class="toc-header">
                <h2 class="toc-title">Guide d'apprentissage Python</h2>
                <div class="progress-info">Progression: 42%</div>
                <div class="progress-bar">
                    <div class="progress-fill"></div>
                </div>
            </div>
            
            <ul class="chapter-list">
                <li class="chapter">
                    <button class="chapter-button">
                        <span>1. Introduction √† Python</span>
                        <span class="icon">‚ñ∂</span>
                    </button>
                    <ul class="section-list">
                        <li><a href="apprendre.html#intro" class="section-link">Qu'est-ce que Python ?</a></li>
                        <li><a href="apprendre.html#installation" class="section-link">Installation et configuration</a></li>
                        <li><a href="apprendre.html#first-program" class="section-link">Votre premier programme</a></li>
                    </ul>
                </li>
                
                <li class="chapter">
                    <button class="chapter-button">
                        <span>2. Fondamentaux</span>
                        <span class="icon">‚ñ∂</span>
                    </button>
                    <ul class="section-list">
                        <li><a href="chapitre2.html#variables" class="section-link">Variables et types de donn√©es</a></li>
                        <li><a href="chapitre2.html#operators" class="section-link">Op√©rateurs</a></li>
                        <li><a href="chapitre2.html#conditions" class="section-link">Structures conditionnelles</a></li>
                        <li><a href="chapitre2.html#loops" class="section-link">Boucles</a></li>
                    </ul>
                </li>
                
                <li class="chapter">
                    <button class="chapter-button">
                        <span>3. Structures de donn√©es</span>
                        <span class="icon">‚ñ∂</span>
                    </button>
                    <ul class="section-list">
                        <li><a href="chapitre3.html#lists" class="section-link active">Listes</a></li>
                        <li><a href="chapitre3.html#tuples" class="section-link">Tuples</a></li>
                        <li><a href="chapitre3.html#dictionaries" class="section-link">Dictionnaires</a></li>
                        <li><a href="chapitre3.html#sets" class="section-link">Ensembles</a></li>
                    </ul>
                </li>
                
                <li class="chapter">
                    <button class="chapter-button">
                        <span>4. Fonctions</span>
                        <span class="icon">‚ñ∂</span>
                    </button>
                    <ul class="section-list">
                        <li><a href="chapitre4.html#definir-fonctions" class="section-link active">D√©finir des fonctions</a></li>
                        <li><a href="chapitre4.html#arguments-retour" class="section-link">Arguments et retour</a></li>
                        <li><a href="chapitre4.html#portee-variables" class="section-link">Port√©e des variables</a></li>
                        <li><a href="chapitre4.html#fonctions-lambda" class="section-link">Fonctions lambda</a></li>
                    </ul>
                </li>
                
                <li class="chapter expanded">
                    <button class="chapter-button active">
                        <span>5. Programmation orient√©e objet</span>
                        <span class="icon">‚ñ∂</span>
                    </button>
                    <ul class="section-list">
                        <li><a href="#classes-objets" class="section-link active">Classes et objets</a></li>
                        <li><a href="#attributs-methodes" class="section-link">Attributs et m√©thodes</a></li>
                        <li><a href="#heritage" class="section-link">H√©ritage</a></li>
                        <li><a href="#polymorphisme" class="section-link">Polymorphisme</a></li>
                    </ul>
                </li>
                
                <li class="chapter">
                    <button class="chapter-button">
                        <span>6. Prochainement...</span>
                        <span class="icon">‚ñ∂</span>
                    </button>
                    <ul class="section-list">
                        <li><a href="prochainement.html" class="section-link">Prochainement...</a></li>
                    </ul>
                </li>
                
                
            </ul>
        </aside>
        
        <main class="content">
            <section class="doc-section" id="classes-objets">
                <h1>Programmation orient√©e objet</h1>
                <p>La programmation orient√©e objet (POO) est un paradigme de programmation qui utilise les "objets" comme composants fondamentaux. Python, en tant que langage multiprogramme, offre un excellent support pour la POO tout en restant simple et intuitif.</p>
                
                <h2>Classes et objets</h2>
                <p>Dans la programmation orient√©e objet, une <strong>classe</strong> est un mod√®le ou un plan pour cr√©er des objets. Un <strong>objet</strong> est une instance d'une classe - une entit√© qui contient des donn√©es et des comportements d√©finis par sa classe.</p>

                <div class="note-box">
                    <div class="box-icon">‚ÑπÔ∏è</div>
                    <div>
                        <p>Pensez √† une classe comme √† un moule √† g√¢teau et aux objets comme aux g√¢teaux cr√©√©s √† partir de ce moule. Le moule d√©finit la forme et la structure, mais chaque g√¢teau peut avoir des ingr√©dients ou des d√©corations diff√©rentes.</p>
                    </div>
                </div>
                
                <h3>Cr√©ation d'une classe</h3>
                <p>En Python, nous utilisons le mot-cl√© <code>class</code> pour cr√©er une classe. La convention de nommage pour les classes est d'utiliser la notation "CamelCase" (premi√®re lettre de chaque mot en majuscule, sans espace).</p>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">classe_simple.py</span>
                        <button class="copy-button"><span class="icon">üìã</span> Copier</button>
                    </div>
                    <div class="copy-message">Copi√© !</div>
                    <pre><code>class Personne:
    """Classe repr√©sentant une personne"""
    pass  # Le mot-cl√© 'pass' permet de d√©finir une classe vide</code></pre>
                </div>

                <h3>Cr√©ation d'objets (instances)</h3>
                <p>Une fois que nous avons d√©fini une classe, nous pouvons cr√©er des objets (instances) de cette classe :</p>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">creation_objets.py</span>
                        <button class="copy-button"><span class="icon">üìã</span> Copier</button>
                    </div>
                    <div class="copy-message">Copi√© !</div>
                    <pre><code>class Personne:
    """Classe repr√©sentant une personne"""
    pass

# Cr√©ation de deux objets de type Personne
person1 = Personne()
person2 = Personne()

print(person1)  # Output: <__main__.Personne object at 0x...>
print(person2)  # Output: <__main__.Personne object at 0x...></code></pre>
                </div>

                <p>Chaque objet cr√©√© est une instance unique de la classe, avec sa propre identit√© (emplacement m√©moire) comme indiqu√© par les adresses diff√©rentes dans l'output.</p>

                <div class="demo-container">
                    <div class="demo-header">
                        <h3 class="demo-title">Exemple pratique: Mod√©liser un compte bancaire</h3>
                    </div>
                    <p>Imaginons que nous voulions mod√©liser un compte bancaire en POO :</p>
                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">compte_bancaire.py</span>
                            <button class="copy-button"><span class="icon">üìã</span> Copier</button>
                        </div>
                        <div class="copy-message">Copi√© !</div>
                        <pre><code>class CompteBancaire:
    """Classe repr√©sentant un compte bancaire"""
    
    def __init__(self, titulaire, solde=0):
        self.titulaire = titulaire
        self.solde = solde
    
    def afficher_details(self):
        print(f"Titulaire: {self.titulaire}")
        print(f"Solde: {self.solde} ‚Ç¨")

# Cr√©ation d'objets CompteBancaire
compte1 = CompteBancaire("Marie Dupont", 1500)
compte2 = CompteBancaire("Jean Martin")

# Acc√®s aux attributs
print(compte1.titulaire)  # Output: Marie Dupont
print(compte2.solde)      # Output: 0

# Appel de m√©thodes
compte1.afficher_details()</code></pre>
                    </div>
                </div>
            </section>
            
            <section class="doc-section" id="attributs-methodes">
                <h2>Attributs et m√©thodes</h2>
                <p>Les classes sont compos√©es d'<strong>attributs</strong> (donn√©es) et de <strong>m√©thodes</strong> (fonctions). Les attributs stockent des informations sur l'objet, tandis que les m√©thodes d√©finissent ce que l'objet peut faire.</p>
                
                <h3>Le constructeur: __init__()</h3>
                <p>La m√©thode <code>__init__()</code> est un constructeur sp√©cial qui est appel√© automatiquement lorsqu'un nouvel objet est cr√©√©. Elle initialise les attributs de l'objet.</p>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">constructeur.py</span>
                        <button class="copy-button"><span class="icon">üìã</span> Copier</button>
                    </div>
                    <div class="copy-message">Copi√© !</div>
                    <pre><code>class Cercle:
    """Classe repr√©sentant un cercle g√©om√©trique"""
    
    def __init__(self, rayon):
        """Initialisation avec le rayon du cercle"""
        self.rayon = rayon  # Attribut d'instance
    
# Cr√©ation d'un cercle avec un rayon de 5
mon_cercle = Cercle(5)
print(mon_cercle.rayon)  # Output: 5</code></pre>
                </div>

                <div class="tip-box">
                    <div class="box-icon">üí°</div>
                    <div>
                        <p>Le param√®tre <code>self</code> fait r√©f√©rence √† l'instance actuelle de la classe et doit √™tre le premier param√®tre de toute m√©thode d'instance. Il est implicitement pass√© lorsqu'une m√©thode est appel√©e, c'est pourquoi vous ne le sp√©cifiez pas lors de l'appel.</p>
                    </div>
                </div>

                <h3>Types d'attributs</h3>
                <p>Il existe deux types principaux d'attributs en Python :</p>
                
                <ul>
                    <li><strong>Attributs d'instance</strong> : Propres √† chaque instance (objet) de la classe</li>
                    <li><strong>Attributs de classe</strong> : Partag√©s par toutes les instances de la classe</li>
                </ul>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">types_attributs.py</span>
                        <button class="copy-button"><span class="icon">üìã</span> Copier</button>
                    </div>
                    <div class="copy-message">Copi√© !</div>
                    <pre><code>class Voiture:
    # Attribut de classe - partag√© par toutes les voitures
    nombre_de_roues = 4
    
    def __init__(self, marque, modele):
        # Attributs d'instance - uniques pour chaque voiture
        self.marque = marque
        self.modele = modele
        self.vitesse = 0
    
# Cr√©ation de deux voitures
voiture1 = Voiture("Renault", "Clio")
voiture2 = Voiture("Peugeot", "208")

# Acc√®s aux attributs d'instance
print(voiture1.marque)  # Output: Renault
print(voiture2.marque)  # Output: Peugeot

# Acc√®s √† l'attribut de classe
print(voiture1.nombre_de_roues)  # Output: 4
print(voiture2.nombre_de_roues)  # Output: 4
print(Voiture.nombre_de_roues)   # Output: 4 - acc√®s via la classe</code></pre>
                </div>

                <h3>Types de m√©thodes</h3>
                <p>Il existe trois types principaux de m√©thodes en Python :</p>
                
                <ul>
                    <li><strong>M√©thodes d'instance</strong> : Op√®rent sur une instance sp√©cifique de la classe</li>
                    <li><strong>M√©thodes de classe</strong> : Op√®rent sur la classe plut√¥t que sur les instances</li>
                    <li><strong>M√©thodes statiques</strong> : Ne d√©pendent ni de la classe ni des instances</li>
                </ul>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">types_methodes.py</span>
                        <button class="copy-button"><span class="icon">üìã</span> Copier</button>
                    </div>
                    <div class="copy-message">Copi√© !</div>
                    <pre><code>class MaClasse:
    compteur = 0  # Attribut de classe
    
    def __init__(self, valeur):
        self.valeur = valeur  # Attribut d'instance
        MaClasse.compteur += 1
    
    # M√©thode d'instance - utilise self
    def methode_instance(self):
        return f"Instance avec valeur: {self.valeur}"
    
    # M√©thode de classe - utilise cls
    @classmethod
    def methode_classe(cls):
        return f"Nombre total d'instances cr√©√©es: {cls.compteur}"
    
    # M√©thode statique - n'utilise ni self ni cls
    @staticmethod
    def methode_statique(x, y):
        return x + y

# Cr√©ation d'instances
obj1 = MaClasse(10)
obj2 = MaClasse(20)

# Appel de la m√©thode d'instance
print(obj1.methode_instance())  # Output: Instance avec valeur: 10

# Appel de la m√©thode de classe
print(MaClasse.methode_classe())  # Output: Nombre total d'instances cr√©√©es: 2

# Appel de la m√©thode statique
print(MaClasse.methode_statique(5, 3))  # Output: 8</code></pre>
                </div>

                <div class="note-box">
                    <div class="box-icon">‚ÑπÔ∏è</div>
                    <div>
                        <p>Les d√©corateurs <code>@classmethod</code> et <code>@staticmethod</code> sont utilis√©s pour d√©finir respectivement les m√©thodes de classe et les m√©thodes statiques.</p>
                    </div>
                </div>

                <h3>Encapsulation</h3>
                <p>L'encapsulation est un concept de POO qui consiste √† regrouper les donn√©es et les m√©thodes qui les manipulent et √† restreindre l'acc√®s direct √† certaines composantes d'un objet.</p>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">encapsulation.py</span>
                        <button class="copy-button"><span class="icon">üìã</span> Copier</button>
                    </div>
                    <div class="copy-message">Copi√© !</div>
                    <pre><code>class CompteBancaire:
    def __init__(self, titulaire, solde=0):
        self.titulaire = titulaire  # Attribut public
        self._solde = solde        # Attribut prot√©g√© (convention)
        self.__numero = "12345"    # Attribut priv√© (name mangling)
    
    def deposer(self, montant):
        if montant > 0:
            self._solde += montant
            return True
        return False
    
    def retirer(self, montant):
        if 0 < montant <= self._solde:
            self._solde -= montant
            return True
        return False
    
    def get_solde(self):
        return self._solde
    
    def get_details(self):
        return f"Titulaire: {self.titulaire}, Solde: {self._solde}‚Ç¨, Num√©ro: {self.__numero}"

# Utilisation
compte = CompteBancaire("Sophie Martin", 1000)

# Acc√®s aux attributs
print(compte.titulaire)      # OK - attribut public
print(compte._solde)         # Techniquement accessible, mais √† √©viter par convention
# print(compte.__numero)     # Erreur - attribut priv√©

# Utilisation des m√©thodes
compte.deposer(500)
compte.retirer(200)
print(compte.get_solde())    # Output: 1300
print(compte.get_details())  # Acc√®s contr√¥l√© via une m√©thode</code></pre>
                </div>

                <div class="warning-box">
                    <div class="box-icon">‚ö†Ô∏è</div>
                    <div>
                        <p>En Python, l'encapsulation est principalement une convention. Les attributs avec un underscore simple (_) sont consid√©r√©s comme "prot√©g√©s" par convention, mais restent accessibles. Les attributs avec un double underscore (__) subissent le "name mangling" qui rend l'acc√®s plus difficile mais pas impossible.</p>
                    </div>
                </div>
            </section>
            
            <section class="doc-section" id="heritage">
                <h2>H√©ritage</h2>
                <p>L'h√©ritage est un m√©canisme qui permet √† une classe de recevoir les attributs et m√©thodes d'une autre classe. La classe qui h√©rite est appel√©e <strong>classe d√©riv√©e</strong> ou <strong>sous-classe</strong>, et la classe dont elle h√©rite est appel√©e <strong>classe de base</strong> ou <strong>classe parent</strong>.</p>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">heritage_simple.py</span>
                        <button class="copy-button"><span class="icon">üìã</span> Copier</button>
                    </div>
                    <div class="copy-message">Copi√© !</div>
                    <pre><code>class Animal:
    def __init__(self, nom):
        self.nom = nom
    
    def manger(self):
        print(f"{self.nom} est en train de manger.")
    
    def dormir(self):
        print(f"{self.nom} est en train de dormir.")

# Chien h√©rite de Animal
class Chien(Animal):
    def aboyer(self):
        print(f"{self.nom} aboie: Woof!")

# Chat h√©rite de Animal
class Chat(Animal):
    def miauler(self):
        print(f"{self.nom} miaule: Meow!")

# Cr√©ation d'instances
mon_chien = Chien("Rex")
mon_chat = Chat("F√©lix")

# Utilisation des m√©thodes h√©rit√©es
mon_chien.manger()   # Output: Rex est en train de manger.
mon_chat.dormir()    # Output: F√©lix est en train de dormir.

# Utilisation des m√©thodes sp√©cifiques
mon_chien.aboyer()   # Output: Rex aboie: Woof!
mon_chat.miauler()   # Output: F√©lix miaule: Meow!</code></pre>
                </div>

                <h3>Super(): Acc√©der aux m√©thodes de la classe parent</h3>
                <p>La fonction <code>super()</code> permet d'appeler des m√©thodes de la classe parent. C'est particuli√®rement utile pour √©tendre le comportement d'une m√©thode h√©rit√©e sans la r√©√©crire compl√®tement.</p>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">utilisation_super.py</span>
                        <button class="copy-button"><span class="icon">üìã</span> Copier</button>
                    </div>
                    <div class="copy-message">Copi√© !</div>
                    <pre><code>class Vehicule:
    def __init__(self, marque, annee):
        self.marque = marque
        self.annee = annee
    
    def description(self):
        return f"{self.marque} ({self.annee})"

class Voiture(Vehicule):
    def __init__(self, marque, annee, modele):
        # Appel du constructeur parent
        super().__init__(marque, annee)
        self.modele = modele
    
    def description(self):
        # Extension de la m√©thode parent
        return f"{super().description()} - {self.modele}"

# Cr√©ation d'une voiture
ma_voiture = Voiture("Toyota", 2020, "Corolla")
print(ma_voiture.description())  # Output: Toyota (2020) - Corolla</code></pre>
                </div>

                <h3>H√©ritage multiple</h3>
                <p>Python permet √† une classe d'h√©riter de plusieurs classes parents, contrairement √† certains langages comme Java.</p>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">heritage_multiple.py</span>
                        <button class="copy-button"><span class="icon">üìã</span> Copier</button>
                    </div>
                    <div class="copy-message">Copi√© !</div>
                    <pre><code>class DispositivElectronique:
    def __init__(self, marque, modele):
        self.marque = marque
        self.modele = modele
        self.allume = False
    
    def allumer(self):
        self.allume = True
        print(f"{self.marque} {self.modele} est maintenant allum√©.")
    
    def eteindre(self):
        self.allume = False
        print(f"{self.marque} {self.modele} est maintenant √©teint.")

class AppareilPhoto:
    def __init__(self, megapixels):
        self.megapixels = megapixels
    
    def prendre_photo(self):
        print(f"Photo prise avec {self.megapixels} megapixels.")

# H√©ritage multiple
class Smartphone(DispositivElectronique, AppareilPhoto):
    def __init__(self, marque, modele, megapixels, systeme_exploitation):
        DispositivElectronique.__init__(self, marque, modele)
        AppareilPhoto.__init__(self, megapixels)
        self.systeme_exploitation = systeme_exploitation
    
    def passer_appel(self, numero):
        if self.allume:
            print(f"Appel en cours vers {numero}...")
        else:
            print("Le t√©l√©phone est √©teint. Impossible de passer un appel.")

# Cr√©ation d'un smartphone
mon_telephone = Smartphone("Samsung", "Galaxy S21", 108, "Android")
mon_telephone.allumer()
mon_telephone.prendre_photo()
mon_telephone.passer_appel("0123456789")</code></pre>
                </div>

                <div class="warning-box">
                    <div class="box-icon">‚ö†Ô∏è</div>
                    <div>
                        <p>L'h√©ritage multiple peut introduire de la complexit√© avec le probl√®me du "diamant" lorsque plusieurs classes parentes h√©ritent d'une m√™me classe d'origine. Python r√©sout ce probl√®me avec l'ordre de r√©solution de m√©thode (MRO).</p>
                    </div>
                </div>
            </section>
            
            <section class="doc-section" id="polymorphisme">
                <h2>Polymorphisme</h2>
                <p>Le polymorphisme est la capacit√© d'utiliser une interface commune pour diff√©rents types de donn√©es. En Python, le polymorphisme est naturel gr√¢ce au typage dynamique.</p>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">polymorphisme.py</span>
                        <button class="copy-button"><span class="icon">üìã</span> Copier</button>
                    </div>
                    <div class="copy-message">Copi√© !</div>
                    <pre><code>class Animal:
    def __init__(self, nom):
        self.nom = nom
    
    def faire_bruit(self):
        pass  # M√©thode √† red√©finir dans les sous-classes

class Chien(Animal):
    def faire_bruit(self):
        return f"{self.nom} aboie: Woof!"

class Chat(Animal):
    def faire_bruit(self):
        return f"{self.nom} miaule: Meow!"

class Canard(Animal):
    def faire_bruit(self):
        return f"{self.nom} cancane: Quack!"

# Fonction polymorphique
def faire_parler_animal(animal):
    print(animal.faire_bruit())

# Cr√©ation d'instances
animaux = [
    Chien("Rex"),
    Chat("F√©lix"),
    Canard("Donald")
]

# Utilisation polymorphique
for animal in animaux:
    faire_parler_animal(animal)

# Output:
# Rex aboie: Woof!
# F√©lix miaule: Meow!
# Donald cancane: Quack!</code></pre>
                </div>

                <div class="tip-box">
                    <div class="box-icon">üí°</div>
                    <div>
                        <p>En Python, le polymorphisme est souvent associ√© au principe "duck typing": "Si √ßa marche comme un canard et √ßa fait coin-coin comme un canard, alors c'est probablement un canard". Cela signifie que l'accent est mis sur le comportement (m√©thodes) plut√¥t que sur le type r√©el de l'objet.</p>
                    </div>
                </div>

                <h3>Surcharge d'op√©rateurs</h3>
                <p>Python permet de personnaliser le comportement des op√©rateurs pour vos propres classes en utilisant des m√©thodes sp√©ciales (ou "dunder methods").</p>

                <div class="code-block">
                    <div class="code-header">
                        <span class="code-title">surcharge_operateurs.py</span>
                        <button class="copy-button"><span class="icon">üìã</span> Copier</button>
                    </div>
                    <div class="copy-message">Copi√© !</div>
                    <pre><code>class Vector:
    def __init__(self, x, y):
        self.x = x
        self.y = y
    
    # Surcharge de l'op√©rateur + pour additionner deux vecteurs
    def __add__(self, other):
        return Vector(self.x + other.x, self.y + other.y)
    
    # Surcharge de l'op√©rateur * pour multiplier par un scalaire
    def __mul__(self, scalar):
        return Vector(self.x * scalar, self.y * scalar)
    
    # Repr√©sentation sous forme de cha√Æne
    def __str__(self):
        return f"Vector({self.x}, {self.y})"
    
    # Repr√©sentation pour le d√©veloppeur
    def __repr__(self):
        return self.__str__()

# Cr√©ation de vecteurs
v1 = Vector(2, 3)
v2 = Vector(5, 7)

# Utilisation des op√©rateurs surcharg√©s
v3 = v1 + v2
v4 = v1 * 2

print(v3)  # Output: Vector(7, 10)
print(v4)  # Output: Vector(4, 6)</code></pre>
                </div>

                <div class="note-box">
                    <div class="box-icon">‚ÑπÔ∏è</div>
                    <div>
                        <p>Python offre de nombreuses m√©thodes sp√©ciales pour personnaliser le comportement des classes. Quelques exemples courants: <code>__init__</code> (constructeur), <code>__str__</code> (conversion en cha√Æne), <code>__len__</code> (longueur), <code>__getitem__</code> (acc√®s par index), etc.</p>
                    </div>
                </div>

                <div class="demo-container">
                    <div class="demo-header">
                        <h3 class="demo-title">Projet pratique: Syst√®me de gestion de biblioth√®que</h3>
                    </div>
                    <p>Ce projet combine plusieurs concepts de POO que nous avons appris :</p>
                    <div class="code-block">
                        <div class="code-header">
                            <span class="code-title">bibliotheque.py</span>
                            <button class="copy-button"><span class="icon">üìã</span> Copier</button>
                        </div>
                        <div class="copy-message">Copi√© !</div>
                        <pre><code>class Publication:
    def __init__(self, titre, annee):
        self.titre = titre
        self.annee = annee
        self.disponible = True
    
    def emprunter(self):
        if self.disponible:
            self.disponible = False
            return True
        return False
    
    def retourner(self):
        self.disponible = True
    
    def afficher_details(self):
        statut = "disponible" if self.disponible else "emprunt√©"
        return f"{self.titre} ({self.annee}) - {statut}"

class Livre(Publication):
    def __init__(self, titre, annee, auteur, pages):
        super().__init__(titre, annee)
        self.auteur = auteur
        self.pages = pages
    
    def afficher_details(self):
        base_info = super().afficher_details()
        return f"{base_info}\nAuteur: {self.auteur}, Pages: {self.pages}"

class Magazine(Publication):
    def __init__(self, titre, annee, editeur, numero):
        super().__init__(titre, annee)
        self.editeur = editeur
        self.numero = numero
    
    def afficher_details(self):
        base_info = super().afficher_details()
        return f"{base_info}\n√âditeur: {self.editeur}, Num√©ro: {self.numero}"

class Bibliotheque:
    def __init__(self, nom):
        self.nom = nom
        self.catalogue = []
    
    def ajouter_publication(self, publication):
        self.catalogue.append(publication)
    
    def chercher_par_titre(self, mot_cle):
        resultats = []
        for pub in self.catalogue:
            if mot_cle.lower() in pub.titre.lower():
                resultats.append(pub)
        return resultats
    
    def afficher_catalogue(self):
        print(f"--- Catalogue de {self.nom} ---")
        for i, pub in enumerate(self.catalogue, 1):
            print(f"{i}. {pub.titre}")

# Utilisation du syst√®me
biblio = Bibliotheque("Biblioth√®que Municipale")

# Ajout de publications
livre1 = Livre("Harry Potter et la Pierre Philosophale", 1997, "J.K. Rowling", 305)
livre2 = Livre("Le Seigneur des Anneaux", 1954, "J.R.R. Tolkien", 423)
mag1 = Magazine("Science & Vie", 2022, "Mondadori", 1253)

biblio.ajouter_publication(livre1)
biblio.ajouter_publication(livre2)
biblio.ajouter_publication(mag1)

# Affichage du catalogue
biblio.afficher_catalogue()

# Recherche de publications
resultats = biblio.chercher_par_titre("harry")
print("\nR√©sultats de recherche:")
for pub in resultats:
    print(pub.afficher_details())

# Emprunt d'un livre
livre1.emprunter()
print("\nApr√®s emprunt:")
print(livre1.afficher_details())</code></pre>
                    </div>
                </div>
            </section>

            <div class="navigation-buttons">
                <button class="nav-button prev" onclick="location.href='chapitre4.html'"><span class="icon">‚Üê </span>Pr√©c√©dent </button>
                <button class="nav-button next" onclick="location.href='prochainement.html'">Suivant <span class="icon">‚Üí</span></button>
            </div>
        </main>
    </div>

    <script>
        // Toggle mobile sidebar
        document.getElementById('mobileToggle').addEventListener('click', function() {
            document.getElementById('sidebar').classList.toggle('active');
        });
        
        // Chapter expand/collapse
        document.querySelectorAll('.chapter-button').forEach(button => {
            button.addEventListener('click', function() {
                const chapter = this.parentElement;
                chapter.classList.toggle('expanded');
            });
        });
        
        // Copy button functionality
        document.querySelectorAll('.copy-button').forEach(button => {
            button.addEventListener('click', function() {
                const codeBlock = this.closest('.code-block');
                const code = codeBlock.querySelector('code').textContent;
                
                navigator.clipboard.writeText(code).then(() => {
                    const copyMessage = codeBlock.querySelector('.copy-message');
                    copyMessage.style.opacity = '1';
                    
                    setTimeout(() => {
                        copyMessage.style.opacity = '0';
                    }, 2000);
                });
            });
        });
    </script>
</body>
</html>